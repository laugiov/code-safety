---
title: CVE Analysis
description: Real-world vulnerability reproductions and detection analysis
---

# CVE Analysis

Testing taint analysis tools against real-world CVE reproductions.

## Included CVEs

### CVE-2022-34265: Django SQL Injection

**Severity:** Critical (9.8)
**Component:** Django Trunc/Extract functions

```python
# Vulnerable pattern
from django.db.models.functions import Trunc

def vulnerable_query(request):
    field = request.GET.get('field')
    # CVE-2022-34265: SQL injection via kind parameter
    Product.objects.annotate(
        truncated=Trunc('created_at', field)  # User-controlled
    )
```

**Detection:**

| Tool | Detected | Notes |
|------|:--------:|-------|
| Pysa | ✅ | Via custom model |
| CodeQL | ✅ | Built-in query |
| Semgrep | ⚠️ | Requires custom rule |

### CVE-2023-36414: Django SQL Injection

**Severity:** High (8.8)
**Component:** Aggregation functions

```python
# Vulnerable pattern
from django.db.models import Aggregate

def vulnerable_aggregate(request):
    func = request.GET.get('function')
    # CVE-2023-36414: SQL injection via function name
    Product.objects.aggregate(
        result=Aggregate(func, 'price')  # User-controlled
    )
```

**Detection:**

| Tool | Detected | Notes |
|------|:--------:|-------|
| Pysa | ✅ | Via Aggregate model |
| CodeQL | ✅ | Built-in query |
| Semgrep | ❌ | Complex pattern |

### Log4Shell Pattern (Python Equivalent)

**Original:** CVE-2021-44228
**Severity:** Critical (10.0)

```python
# Python equivalent of Log4Shell pattern
import logging

def log_user_input(request):
    user_agent = request.META.get('HTTP_USER_AGENT')
    # Dangerous: logging user-controlled data with format
    logging.info(f"User agent: {user_agent}")

    # Even worse: using % formatting
    logging.info("User: %s" % request.GET.get('user'))
```

**Detection:**

| Tool | Detected | Notes |
|------|:--------:|-------|
| Pysa | ✅ | Logging sink model |
| CodeQL | ✅ | Logging query |
| Semgrep | ✅ | Pattern rule |

## Detection Summary

| CVE | Pysa | CodeQL | Semgrep |
|-----|:----:|:------:|:-------:|
| CVE-2022-34265 | ✅ | ✅ | ⚠️ |
| CVE-2023-36414 | ✅ | ✅ | ❌ |
| Log4Shell Pattern | ✅ | ✅ | ✅ |

## Adding Custom CVE Reproductions

### Directory Structure

```
benchmarks/cve-reproductions/
├── cve_2022_34265.py
├── cve_2023_36414.py
├── log4shell_pattern.py
└── README.md
```

### Template

```python
"""
CVE-YYYY-XXXXX: Vulnerability Name

Severity: Critical/High/Medium/Low
Component: Affected component
References:
  - https://nvd.nist.gov/vuln/detail/CVE-YYYY-XXXXX
  - https://github.com/advisories/...

Expected Detection:
  - Pysa: Yes (rule XXXX)
  - CodeQL: Yes (query name)
  - Semgrep: Yes/No (rule name)
"""

def vulnerable_function(user_input):
    """
    Vulnerable pattern reproduction.

    This demonstrates the vulnerability pattern without
    exposing actual exploitation code.
    """
    # Vulnerable code here
    pass

def fixed_function(user_input):
    """
    Recommended fix for the vulnerability.
    """
    # Fixed code here
    pass
```

## Running CVE Benchmarks

```bash
cd benchmarks

# Test specific CVE
python scripts/run_benchmarks.py --cve CVE-2022-34265

# Test all CVEs
python scripts/run_benchmarks.py --cve-all

# Generate CVE report
python scripts/generate_report.py --format html --cve-only
```

## Lessons Learned

### Pattern Recognition

1. **Framework-specific sinks** require custom models
2. **Dynamic function names** are hard to track
3. **Configuration-based vulnerabilities** need pattern matching

### Improving Detection

```python
# Pysa: Add Django function sink
def django.db.models.functions.Trunc.__init__(
    self,
    expression,
    kind: TaintSink[SQL],
    ...
): ...

# Semgrep: Custom rule
rules:
  - id: django-trunc-injection
    pattern: Trunc($EXPR, $KIND, ...)
    message: Potential SQL injection via Trunc kind parameter
```

## Contributing

Found a CVE that should be included? Submit a PR with:

1. Minimal reproduction code
2. Expected detection by each tool
3. References to original advisory
