"""
CVE-2022-34265: Django SQL Injection via Trunc(kind) and Extract(lookup_name)

================================================================================
CVE Information
================================================================================
CVE ID:        CVE-2022-34265
Product:       Django
Affected:      Django 3.2 before 3.2.14, 4.0 before 4.0.6
Severity:      CRITICAL (CVSS 9.8)
CWE:           CWE-89 (SQL Injection)
Published:     2022-07-04

Description:
    An issue was discovered in Django 3.2 before 3.2.14 and 4.0 before 4.0.6.
    The Trunc() and Extract() database functions are subject to SQL injection
    if untrusted data is used as a kind/lookup_name value.

    This is the predecessor to CVE-2023-36414, demonstrating that similar
    patterns can recur even after initial fixes.

References:
    - https://nvd.nist.gov/vuln/detail/CVE-2022-34265
    - https://www.djangoproject.com/weblog/2022/jul/04/security-releases/
    - https://github.com/django/django/commit/5e2f4dd

================================================================================
Taint Flow Analysis
================================================================================
Source:        HTTP request parameter
Sink:          Django database function (Trunc/Extract)
Propagation:   Direct assignment without sanitization
Detection:     All tools should detect with proper Django ORM modeling

================================================================================
"""

from django.db.models.functions import Trunc, Extract
from django.db.models import Sum, Avg
from django.http import JsonResponse, HttpResponse

# Mock models
class Transaction:
    objects = None

class Event:
    objects = None


# ==============================================================================
# VULNERABLE CODE PATTERNS
# ==============================================================================

def vulnerable_transaction_report(request):
    """
    VULNERABLE: SQL injection through Trunc 'kind' parameter

    Original CVE pattern where user input flows directly to Trunc().

    Payload example:
        ?interval=day'%29%3BSELECT%20pg_sleep%2810%29--

    This would generate SQL like:
        TRUNC("timestamp", 'day');SELECT pg_sleep(10)--')
    """
    # VULN: Untrusted input directly used in database function
    interval = request.GET.get('interval', 'day')  # SOURCE: UserControlled

    # The 'kind' parameter is not sanitized by Django in affected versions
    transactions = Transaction.objects.annotate(
        time_bucket=Trunc('timestamp', kind=interval)  # SINK: SQL Injection
    ).values('time_bucket').annotate(
        total_amount=Sum('amount')
    )

    return JsonResponse({'transactions': list(transactions)})


def vulnerable_event_analytics(request):
    """
    VULNERABLE: SQL injection through Extract 'lookup_name'

    Uses POST data, demonstrating various input vectors.
    """
    # VULN: POST parameter used in Extract
    date_part = request.POST.get('date_part', 'hour')  # SOURCE: UserControlled

    analytics = Event.objects.annotate(
        time_part=Extract('occurred_at', lookup_name=date_part)  # SINK: SQL Injection
    ).values('time_part').annotate(
        event_count=Sum('id')
    )

    return JsonResponse({'analytics': list(analytics)})


def vulnerable_multi_aggregate(request):
    """
    VULNERABLE: Multiple injections in single query

    Complex query with multiple user-controlled parameters.
    """
    group_interval = request.GET.get('group', 'month')  # SOURCE 1
    extract_field = request.GET.get('extract', 'year')  # SOURCE 2

    # Both parameters are vulnerable
    data = Transaction.objects.annotate(
        period=Trunc('timestamp', kind=group_interval),  # SINK 1
        year_part=Extract('timestamp', lookup_name=extract_field)  # SINK 2
    ).values('period', 'year_part').annotate(
        avg_amount=Avg('amount')
    )

    return JsonResponse({'data': list(data)})


def vulnerable_with_variable_propagation(request):
    """
    VULNERABLE: Multi-step taint propagation

    Tests tool ability to track taint through intermediate variables.
    """
    # Step 1: Source
    user_input = request.GET.get('period')  # SOURCE

    # Step 2: Intermediate assignment
    selected_period = user_input if user_input else 'month'

    # Step 3: Further propagation
    trunc_kind = selected_period.lower()

    # Step 4: Sink
    result = Transaction.objects.annotate(
        bucket=Trunc('created_at', kind=trunc_kind)  # SINK
    ).values('bucket')

    return JsonResponse({'result': list(result)})


# ==============================================================================
# SECURE CODE PATTERNS (FIXED)
# ==============================================================================

# Constants for allowed values (from Django 3.2.14+)
ALLOWED_KINDS = frozenset({
    'year', 'iso_year', 'quarter', 'month', 'week', 'day',
    'hour', 'minute', 'second',
})

ALLOWED_LOOKUPS = frozenset({
    'year', 'iso_year', 'month', 'day', 'week', 'week_day',
    'iso_week_day', 'quarter', 'hour', 'minute', 'second',
})


def secure_transaction_report(request):
    """
    SECURE: Input validation with allowlist

    Django 3.2.14+ performs this validation internally, but explicit
    validation provides defense in depth.
    """
    interval = request.GET.get('interval', 'day')

    # SECURE: Explicit allowlist validation
    if interval not in ALLOWED_KINDS:
        return JsonResponse({
            'error': 'Invalid interval',
            'valid_options': list(ALLOWED_KINDS)
        }, status=400)

    transactions = Transaction.objects.annotate(
        time_bucket=Trunc('timestamp', kind=interval)  # Safe after validation
    ).values('time_bucket').annotate(
        total_amount=Sum('amount')
    )

    return JsonResponse({'transactions': list(transactions)})


def secure_event_analytics(request):
    """
    SECURE: Enum-based approach for type safety
    """
    from enum import Enum

    class DatePart(Enum):
        YEAR = 'year'
        MONTH = 'month'
        DAY = 'day'
        HOUR = 'hour'

    date_part_input = request.POST.get('date_part', 'hour')

    # SECURE: Convert to enum (raises ValueError if invalid)
    try:
        date_part = DatePart(date_part_input)
    except ValueError:
        return JsonResponse({
            'error': 'Invalid date_part',
            'valid_options': [e.value for e in DatePart]
        }, status=400)

    analytics = Event.objects.annotate(
        time_part=Extract('occurred_at', lookup_name=date_part.value)
    ).values('time_part').annotate(
        event_count=Sum('id')
    )

    return JsonResponse({'analytics': list(analytics)})


def secure_with_mapping(request):
    """
    SECURE: User-friendly names mapped to safe values

    Provides flexibility while maintaining security.
    """
    # Map user-friendly names to validated internal values
    PERIOD_MAPPING = {
        'yearly': 'year',
        'quarterly': 'quarter',
        'monthly': 'month',
        'weekly': 'week',
        'daily': 'day',
        'hourly': 'hour',
    }

    user_period = request.GET.get('period', 'monthly')

    # SECURE: Only mapped values are used
    if user_period not in PERIOD_MAPPING:
        return JsonResponse({
            'error': 'Invalid period',
            'valid_options': list(PERIOD_MAPPING.keys())
        }, status=400)

    safe_period = PERIOD_MAPPING[user_period]

    result = Transaction.objects.annotate(
        bucket=Trunc('created_at', kind=safe_period)
    ).values('bucket')

    return JsonResponse({'result': list(result)})


# ==============================================================================
# Detection Test Cases
# ==============================================================================

"""
Expected Detections:

Tool Detection Matrix:
------------------------------------------------------------------------------
Function                              | Pysa  | CodeQL | Semgrep | Notes
------------------------------------------------------------------------------
vulnerable_transaction_report         |  ✓    |   ✓    |    ✓    | Direct flow
vulnerable_event_analytics            |  ✓    |   ✓    |    ✓    | POST variant
vulnerable_multi_aggregate            |  ✓    |   ✓    |    ✓    | Multiple sinks
vulnerable_with_variable_propagation  |  ✓    |   ✓    |    ?    | Multi-step
secure_transaction_report             |  ✗    |   ✗    |    ✗    | Sanitized
secure_event_analytics                |  ✗    |   ✗    |    ✗    | Enum validated
secure_with_mapping                   |  ✗    |   ✗    |    ✗    | Mapping safe
------------------------------------------------------------------------------

Key Detection Requirements:
1. Model request.GET.get() as taint source
2. Model Trunc() kind parameter as SQL sink
3. Model Extract() lookup_name parameter as SQL sink
4. Track taint through variable assignments
5. Recognize allowlist validation as sanitizer
"""
