"""
CVE-2023-36414: Django Trunc/Extract SQL Injection

================================================================================
CVE Information
================================================================================
CVE ID:        CVE-2023-36414
Product:       Django
Affected:      Django 3.2 before 3.2.21, 4.1 before 4.1.11, 4.2 before 4.2.5
Severity:      HIGH (CVSS 8.8)
CWE:           CWE-89 (SQL Injection)
Published:     2023-09-04

Description:
    In Django 3.2 before 3.2.21, 4.1 before 4.1.11, and 4.2 before 4.2.5,
    the Trunc() and Extract() database functions are subject to SQL injection
    if untrusted data is used as a kind/lookup_name value.

References:
    - https://nvd.nist.gov/vuln/detail/CVE-2023-36414
    - https://www.djangoproject.com/weblog/2023/sep/04/security-releases/
    - https://github.com/django/django/commit/5c14d3a

================================================================================
Taint Flow Analysis
================================================================================
Source:        HTTP request parameter (kind/lookup_name)
Sink:          Django ORM Trunc/Extract function
Propagation:   Request → variable → database function argument
Detection:     Requires understanding of Django ORM functions as SQL sinks

================================================================================
"""

from django.db.models.functions import Trunc, Extract
from django.db.models import Count
from django.http import JsonResponse

# Mock models for demonstration
class Order:
    """Mock Order model"""
    objects = None


# ==============================================================================
# VULNERABLE CODE PATTERN
# ==============================================================================

def vulnerable_sales_report(request):
    """
    VULNERABLE: User-controlled 'kind' parameter passed directly to Trunc()

    The 'kind' parameter in Trunc() is not properly sanitized and can be
    used to inject arbitrary SQL.

    Exploit example:
        GET /api/sales-report/?group_by=year'%3B%20DROP%20TABLE%20orders%3B--

    Taint flow:
        request.GET.get('group_by') → kind parameter → Trunc() → SQL execution
    """
    # VULN: User input used directly as Trunc kind parameter
    group_by = request.GET.get('group_by', 'month')  # SOURCE: UserControlled

    # This SQL injection occurs because 'kind' is interpolated into SQL
    # without proper validation
    sales_data = Order.objects.annotate(
        period=Trunc('created_at', kind=group_by)  # SINK: SQL Injection
    ).values('period').annotate(
        total=Count('id')
    ).order_by('period')

    return JsonResponse({'data': list(sales_data)})


def vulnerable_extract_report(request):
    """
    VULNERABLE: User-controlled 'lookup_name' in Extract()

    Similar vulnerability pattern with Extract() function.
    """
    # VULN: User input used as Extract lookup_name
    field = request.GET.get('field', 'year')  # SOURCE: UserControlled

    report = Order.objects.annotate(
        extracted=Extract('created_at', lookup_name=field)  # SINK: SQL Injection
    ).values('extracted').annotate(
        count=Count('id')
    )

    return JsonResponse({'data': list(report)})


# ==============================================================================
# SECURE CODE PATTERN (FIXED)
# ==============================================================================

# Allowlist of valid Trunc/Extract values
VALID_TRUNC_KINDS = {'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second'}
VALID_EXTRACT_FIELDS = {'year', 'month', 'day', 'hour', 'minute', 'second', 'week_day'}


def secure_sales_report(request):
    """
    SECURE: Validate group_by against allowlist before using in Trunc()

    The fix validates that the user-provided value is in an allowlist
    of known-safe values before passing to the database function.
    """
    group_by = request.GET.get('group_by', 'month')

    # SECURE: Validate against allowlist
    if group_by not in VALID_TRUNC_KINDS:
        return JsonResponse(
            {'error': f'Invalid group_by. Must be one of: {VALID_TRUNC_KINDS}'},
            status=400
        )

    # Safe: group_by is now guaranteed to be a valid, safe value
    sales_data = Order.objects.annotate(
        period=Trunc('created_at', kind=group_by)
    ).values('period').annotate(
        total=Count('id')
    ).order_by('period')

    return JsonResponse({'data': list(sales_data)})


def secure_extract_report(request):
    """
    SECURE: Validate field against allowlist before using in Extract()
    """
    field = request.GET.get('field', 'year')

    # SECURE: Validate against allowlist
    if field not in VALID_EXTRACT_FIELDS:
        return JsonResponse(
            {'error': f'Invalid field. Must be one of: {VALID_EXTRACT_FIELDS}'},
            status=400
        )

    report = Order.objects.annotate(
        extracted=Extract('created_at', lookup_name=field)
    ).values('extracted').annotate(
        count=Count('id')
    )

    return JsonResponse({'data': list(report)})


# ==============================================================================
# Test Detection Markers
# ==============================================================================

"""
Expected Detections:

Pysa:
    - Rule 5001 (SQL Injection): UserControlled → SQL sink
    - Should detect both Trunc and Extract patterns

CodeQL:
    - py/vulnshop-sql-injection
    - Tracks from request.GET.get() to ORM function

Semgrep:
    - sql-injection-orm-function
    - Pattern matches Trunc/Extract with user input

Taint Source: request.GET.get('group_by') / request.GET.get('field')
Taint Sink: Trunc(..., kind=...) / Extract(..., lookup_name=...)
"""
